# SDLC, Software Developement Life Cycle
## SDLC 단계
1. 계획  
: 사업계획, 리소스, 일정 계획, 위험요소 식별 

    * 산출물 : 프로젝트 계획서, 리스크 관리 보고서

2. 요구사항 정의  
: 요구사항 수집과 정의분석  
문서화, 기능 정의, 릴리즈 일정, 디자인 정의  

    * 산출물 : 기능 정의서, 요구사항 명세서, 사용자 시나리오

3. 설계  
: 서버, 아키텍처 설계  

    * 산출물 : DB 설계서, UI Prototype

4. 구현  
: 소스코드 구현 및 빌드

    * 산출물 : 소스 코드

5. 테스트, 배포  
: 기능 및 성능 검증, 결함 발견 및 수정

    * 산출물 : Test Case, 테스트 결과 보고서, 결함 목록

6. 유지보수

<br/>

## SDLC 모델

* Waterfall
    * 순차 개발, 기능 구현에 집중
    * 최종 제품 단계에서 고객 피드백 반영
    * 명확한 계획과 예측 가능성 필요

<br/>

* Agile
    * 반복적(iteration), 점진적(incremental) 개발
    * 스프린트마다 고객 피드백 반영
    * 관리 복잡성, 일정 예측이 어려움

<br/>

# 계획
* 프로젝트 목표 설정 기준(SMART)
    * Specific : 구체적
    * Measurable : 측정 가능
    * Action-oriented : 실천 지향적
    * Realistic : 현실적
    * Time-limited : 기한 준수

<br/>

* 리소스와 일정 계획
    * 간트차트(Gantt)  
        : 마일스톤(주요 목표나 단계의 달성을 나타내는 이정표) 설정  
        일정관리, 작업 순서와 의존성 확인

<br/>

* 위험 평가 및 관리
    * 리스크 매트릭스

<br/>

* 계획 단계 성과 측정 방법
    * KPI, Key Performance Indicator
        * 계획 완료율
        * 리스크 식별률
        * 자원 할당 정확도
        * 테스트 툴 사용률
        * 스크립트 작성률

# 요구사항 정의
: 목표와 범위 구체화 과정, 사용자와 직군별 시점으로 기능에 대한 피드백 공유 

* 요구사항 수집 방법
    * 인터뷰
    * 설문조사
    * 워크숍

> <span style="color:darkgray">**모든 구성원이 참여하여  
개발 진행 방식, 데이터 흐름, 기능에 대한 이해(무엇을 만드는가)등  
프로젝트에 대한 이해를 마쳐야 함(애자일 기준)**</span>

<br/>

* 요구사항 분석
    1. 요구사항 분류
    2. 충돌 요구사항 해결
    3. 기술적 타당성 검토

<br/>

* 요구사항 분석 도구
    * UML, Unified Modeling Language
    : 개발을 위해 각 구성요소 간의 관계를 도식화(표준화)한 설계도

    * 구조 다이어그램(Structure Diagram)  
        Class Diagram
        : 클래스 - 메소드 간의 관계 도식화

    * 행위 다이어그램(Behavior Diagram)   
        유스케이스 다이어그램
        : 사용자 흐름을 시각적으로 표현

<br/>

* 요구사항 우선순위화 기법
    * MoSCow 기법
        * Must Have : 핵심 기능
        * Should Have : 필수는 아니지만 우선순위가 높은 기능
        * Could Have : 제품 혹은 서비스의 성공 여부에 큰 영향을 끼치지 않는 기능
        * Won't Have : 당장 필요로 하지 않는 기능

    * Kano 모델
        : 고객 만족과 불만에 영향을 주는 매력적 요소, 일원적 요소, 당연적 요소를 구분

> <span style="color:darkgray">**결론적으로, 제품의 핵심 기능이 우선순위가 높을 수 밖에 없음**</span>

<br/>

* 요구사항 변경 관리
    1. 변경 요청 수집
    2. 영향도 분석
    3. 승인 및 재 조정

<br/>

# 설계
: 요구사항 정의 단계에서 도출된 정보를 바탕으로 구조와 동작 방식을 구체화  
sw 생명주기가 중단되지 않도록 설계해야함

> <span style="color:darkgray">**QA : 개발자 툴 세팅 지원, 테스트 계획/일정 수립, TC 작성**</span>

* sw 아키텍처
: 시스템 전반의 구조와 설계를 정의하는 틀, 지침서  
데이터 흐름과 설계 방식에 대해 문서화 하는 것

<br/>

* sw 아키텍처 설계 유형
    * Monolithic(계층형)  
    : FE, BE, DB를 계층적으로 분리하여 설계

    * Microservice Architecture  
    : 각 기능을 분리 설계하여 대규모 트래픽, 유지보수에 용이  
    비용이 많이들고 복잡성이 높음

    * Serverless  
    : 클라우드 플랫폼을 활용하여 서버 관리 부담 감소

<br/>

* 데이터 흐름 설계
    * 데이터 흐름 다이어그램(DFD)  
    : 데이터 입력, 처리, 저장및 출력 단계를 다이어그램으로 작성
    
        > <span style="color:darkgray">**DFD를 현업에서 잘 사용하지는 않음**</span>

<br/>

> <span style="color:darkgray">**각 구성원의 학습 수준, 일정 등을 고려하여 프로젝트를 설계해야 함**</span>

<br/>

# 구현
* 코딩 원칙
    * Clean Code
    : 가독성 있는 코드 작성
        * 코딩 표준, 아키텍처 표준, 설계 가이드 준수
        * 복잡함 최소화
        * 참조되거나 수정되는 코드는 기존 코드보다 가독성이 있어야 함
        * 반복성 최소화
        * 하나의 파일은 하나의 언어로 작성

    * DRY, Dont Repeat Yourself
    : 반복 코드 최소화

    * SOLID 원칙

<br/>

* 빌드 프로세스
    1. 코드 컴파일
    2. 의존성 설치
    3. 실행파일 생성
    4. 오류 검토 및 경고

<br/>

* 버전 관리  
: 소스 코드의 변경 사항을 추적하고, 팀원 간 협업을 지원하는 시스템

> <span style="color:darkgray">**구현 단계에서 QA가 개발자 코드에 테스트코드/스크립트를 작성하는 역할을 맡기도 함**</span>

<br/>

# 테스트
* 테스트 계획
    * 구성 : 테스트 범위, 목표, 일정, 리소스

<br/>

* 테스트 유형
    * 기능 테스트  
    : 요구된 기능을 제대로 수행하는지 검증

    * 성능 테스트  
    : Load Test(부하 테스트), Stress Test(스트레스 테스트)

    * 회귀 테스트  
    : 새로운 코드 변경이 기존 기능에 문제를 발새시키지 않는지 확인

    * 보안 테스트  
    : 시스템 보안 취약점 탐지

<br/>

* 테스트 자동화 툴
    * 웹 자동화
    : Selenium, Sypress
    * 단위테스트
    JUnit, TestNG
    * API
    Postman

> <span style="color:darkgray">**개발자가 사용할 테스트 코드 짜야하므로 대세인 자바를 아는게 좋음  
AI 관련된 것은 파이썬이 유리함**</span>

* 결함 관리 프로세스
    1. Defect Reporting
    2. Defect Analysis
    3. Detect Fixing
    4. Retest

<br/>

# 배포
* 배포 프로세스
    1. 준비
    2. 테스트 환경 준비
    3. 프로덕션 환경
    4. 사용자 제공

* 배포 전략

    > <span style="color:darkgray">**일반적인 배포 방식  
    1.기존 서버 중단(점검중 화면 출력)  
    2.배포 완료 후 사이트 운영 개시**</span>

    * Blue/Green(무중단 배포)
        1. 기존 서버 운영 + 신규 서버 배포
        2. 신규 서버로 트래픽 연결
        3. 기존 서버로 연결된 트래픽이 없어지면 기존 서버 셧다운, 신규 서버만 운영

        * 로드밸런서 : 트래픽 분배를 위한 스위치

    * Canary
        1. 100% 사용자 중, 소규모 그룹에 먼저 배포하여 안정성 확인
        2. 신규 배포 사용자를 점차적으로 증가시킴

    * Rolling
        1. 기존 시스템 일부 셧다운, 신규 서버로 연결
        2. 이를 반복하여 순차적으로 교체하는 방식으로 새로운 버전 배포

<br/>

# 유지보수
* 종류
    * 수정 유지보수
    * 적응 유지보수
    * 예방 유지보수
    * 기능 추가 유지보수

<br/>

* 유지보수 핵심 원칙
    * 사용자 피드백을 기반으로 한 지속적인 개선
    * 문서화를 통한 이력 확보
    * 장기적인 안정성을 고려한 업데이트

<br/>

* 사용자 피드백
    * 애널리틱스 도구(Google Analytics, Firebase)
    * 사용자 리뷰 및 평가
    * 온라인 설문조사

<br/>

* 자동화 도구
    * Log 관리
    : Splunk, ELK Stack

    * 모니터링 도구
    : Grapana, New Relic, Datadog
    
    * 자동화 배포 도구
    : Jenkins, CI/CD
